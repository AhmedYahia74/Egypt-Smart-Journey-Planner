Index: actions/validation_action.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import requests\nfrom rasa_sdk import Tracker, FormValidationAction\nfrom rasa_sdk.executor import CollectingDispatcher\nfrom typing import Any, Text, Dict, List, Tuple, Optional, Union\nfrom datetime import datetime, timedelta\nfrom dateutil.relativedelta import relativedelta\nimport logging\nfrom contextlib import contextmanager\nfrom word2number import w2n\nfrom config_helper import get_db_params, get_api_urls\nimport psycopg2\nimport re\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\nDB_Prams = get_db_params()\n\n@contextmanager\ndef get_db_connection():\n    conn = None\n    try:\n        conn = psycopg2.connect(**DB_Prams)\n        yield conn\n    except psycopg2.Error as e:\n        logger.error(f\"Database error: {str(e)}\")\n        raise\n    finally:\n        if conn:\n            conn.close()\n\ndef fetch_cities_from_database():\n    # Fetch cities from a database\n    try:\n        with get_db_connection() as conn:\n            with conn.cursor() as cur:\n                cur.execute(\"SELECT * FROM states\")\n                return [row[1] for row in cur.fetchall()]\n    except Exception as e:\n        logger.error(f\"Error fetching cities: {str(e)}\")\n        return []\n\nCITIES_NAMES = fetch_cities_from_database()\n\n\nclass ValidateTripForm(FormValidationAction):\n\n    def name(self) -> Text:\n        return \"validate_trip_form\"\n\n    async def required_slots(\n            self,\n            domain_slots: List[Text],\n            dispatcher: \"CollectingDispatcher\",\n            tracker: \"Tracker\",\n            domain: Dict[Text, Any],\n    ) -> List[Text]:\n        required_slots = []\n\n        # If we don't have specify_place yet, ask for it first\n        if not tracker.get_slot(\"state\"):\n            if tracker.get_slot(\"specify_place\") is None or tracker.get_slot(\"requested_slot\") == \"specify_place\":\n                required_slots.append(\"specify_place\")\n                return required_slots\n\n            # If specify_place is True but no state, ask for state\n            if tracker.get_slot(\"specify_place\"):\n                required_slots.append(\"state\")\n                return required_slots\n\n            # If specify_place is False, ask for city description\n            if not tracker.get_slot(\"specify_place\") and not tracker.get_slot(\"city_description\"):\n                required_slots.append(\"city_description\")\n                return required_slots\n\n            # If we have city description but no selected city, and we're awaiting city selection\n            if (tracker.get_slot(\"city_description\") and\n                not tracker.get_slot(\"selected_city\") and\n                tracker.get_slot(\"awaiting_city_selection\")):\n                required_slots.append(\"selected_city\")\n                return required_slots\n            if (tracker.get_slot(\"city_description\") and\n                    not tracker.get_slot(\"awaiting_city_selection\")):\n                return [\"city_description\"]\n        # After we have the state, check for other required slots\n        else:\n            # Check each required slot in order\n            if not tracker.get_slot(\"budget\") or tracker.get_slot(\"requested_slot\") == \"budget\":\n                required_slots.append(\"budget\")\n            if not tracker.get_slot(\"duration\") or tracker.get_slot(\"requested_slot\") == \"duration\":\n                required_slots.append(\"duration\")\n            if not tracker.get_slot(\"arrival_date\") or tracker.get_slot(\"requested_slot\") == \"arrival_date\":\n                required_slots.append(\"arrival_date\")\n            if not tracker.get_slot(\"hotel_features\") or tracker.get_slot(\"requested_slot\") == \"hotel_features\":\n                required_slots.append(\"hotel_features\")\n            if not tracker.get_slot(\"landmarks_activities\") or tracker.get_slot(\"requested_slot\") == \"landmarks_activities\":\n                required_slots.append(\"landmarks_activities\")\n\n        return required_slots\n\n    @staticmethod\n    def validate_specify_place(slot_value: Any,\n                               dispatcher: CollectingDispatcher,\n                               tracker: Tracker,\n                               domain: Dict[Text, Any]) -> Dict[Text, Any]:\n        intent = tracker.latest_message['intent'].get('name')\n        text = tracker.latest_message.get('text', '').lower()\n\n        # First check if there's a state entity\n        entities = tracker.latest_message.get('entities', [])\n        for entity in entities:\n            if entity.get('entity') == 'state':\n                state_value = entity.get('value')\n                if state_value.lower() in [city.lower() for city in CITIES_NAMES]:\n                    return {\n                        \"specify_place\": True,\n                        \"state\": state_value,\n                        \"requested_slot\": \"budget\"\n                    }\n        \n        # Handle other intents\n        if intent == \"affirm\":\n            # Check if there's a city mentioned in the text\n            for city in CITIES_NAMES:\n                if city.lower() in text:\n                    return {\n                        \"specify_place\": True,\n                        \"state\": city,\n                        \"requested_slot\": \"budget\"\n                    }\n            # If no city was mentioned, just set specify_place to True\n            return {\n                \"specify_place\": True,\n                \"requested_slot\": \"state\"\n            }\n        elif intent == \"deny\":\n            return {\n                \"specify_place\": False,\n                \"requested_slot\": \"city_description\"\n            }\n        \n        # If we get here, check if there's a city in the text\n        for city in CITIES_NAMES:\n            if city.lower() in text:\n                return {\n                    \"specify_place\": True,\n                    \"state\": city,\n                    \"requested_slot\": \"budget\"\n                }\n\n        return {\"specify_place\": None}\n\n    @staticmethod\n    def validate_city_description(self, slot_value: Any, dispatcher: CollectingDispatcher, tracker: Tracker,\n                                  domain: Dict[Text, Any]) -> Dict[Text, Any]:\n        try:\n            api_url = get_api_urls()\n            if not api_url:\n                raise KeyError(\"'suggest_cities' key not found in API URLs configuration\")\n\n            # Extract city features from the description\n            city_features = []\n            if isinstance(slot_value, str):\n                # Common non-Egyptian features to check for\n                non_egyptian_features = {\n                    'ski slopes': 'Egypt doesn\\'t have ski slopes, but we have beautiful desert landscapes',\n                    'volcanoes': 'Egypt doesn\\'t have volcanoes, but we have ancient pyramids and temples',\n                    'rainforests': 'Egypt doesn\\'t have rainforests, but we have the Nile Valley and oases',\n                    'polar bears': 'Egypt doesn\\'t have polar bears, but we have unique desert wildlife',\n                    'northern lights': 'Egypt doesn\\'t have northern lights, but we have amazing desert sunsets',\n                    'ice hotels': 'Egypt doesn\\'t have ice hotels, but we have luxury desert camps',\n                    'fjords': 'Egypt doesn\\'t have fjords, but we have the beautiful Red Sea coast',\n                    'hot springs': 'Egypt doesn\\'t have hot springs, but we have natural hot springs in Siwa Oasis',\n                    'tulip fields': 'Egypt doesn\\'t have tulip fields, but we have beautiful desert flowers',\n                    'cherry blossoms': 'Egypt doesn\\'t have cherry blossoms, but we have beautiful palm trees',\n                    'kangaroos': 'Egypt doesn\\'t have kangaroos, but we have unique desert wildlife',\n                    'koalas': 'Egypt doesn\\'t have koalas, but we have camels and desert animals',\n                    'penguins': 'Egypt doesn\\'t have penguins, but we have beautiful marine life in the Red Sea',\n                    'glaciers': 'Egypt doesn\\'t have glaciers, but we have the White Desert',\n                    'rainbow mountains': 'Egypt doesn\\'t have rainbow mountains, but we have the Colored Canyon',\n                    'bamboo forests': 'Egypt doesn\\'t have bamboo forests, but we have date palm groves',\n                    'giant sequoia trees': 'Egypt doesn\\'t have sequoia trees, but we have ancient palm trees',\n                    'coral atolls': 'Egypt doesn\\'t have coral atolls, but we have the Red Sea coral reefs',\n                    'icebergs': 'Egypt doesn\\'t have icebergs, but we have the White Desert formations',\n                    'polar nights': 'Egypt doesn\\'t have polar nights, but we have beautiful desert nights',\n                    'midnight sun': 'Egypt doesn\\'t have midnight sun, but we have amazing desert sunsets',\n                    'geysers': 'Egypt doesn\\'t have geysers, but we have natural hot springs',\n                    'rainbow lakes': 'Egypt doesn\\'t have rainbow lakes, but we have the Magic Lake in Fayoum'\n                }\n\n                # Check for non-Egyptian features and provide alternatives\n                for feature, alternative in non_egyptian_features.items():\n                    if feature.lower() in slot_value.lower():\n                        dispatcher.utter_message(f\"Note: {alternative}\")\n            cities_url=f\"{api_url['base_url']}/cities/search\"\n            response = requests.post(\n                cities_url,\n                json={\n                    \"city_description\": slot_value,\n                    \"city_features\": city_features\n                }\n            )\n            if response.status_code == 200:\n                suggested_cities = response.json().get(\"top_cities\", [])\n                \n                if suggested_cities:\n                    # Format the cities for display\n                    suggested_cities_msg = \"\\n\".join(\n                        [f\"{i+1}. {city['name']} - {city['description']}\" for i, city in enumerate(suggested_cities)]\n                    )\n                    \n                    dispatcher.utter_message(text=f\"Here are some suggested cities that may suit you:\\n{suggested_cities_msg}\")\n                    dispatcher.utter_message(text=\"Please choose one of these cities for your trip.\")\n                    \n                    # Store just the city names in the suggested_cities slot\n                    city_names = [city['name'] for city in suggested_cities]\n                    \n                    # Store the city description and set awaiting_city_selection to true\n                    return {\n                        \"city_description\": slot_value,\n                        \"city_features\": city_features,\n                        \"suggested_cities\": city_names,\n                        \"awaiting_city_selection\": True,\n                        \"requested_slot\": \"selected_city\"\n                    }\n                else:\n                    dispatcher.utter_message(\"I couldn't find any cities matching your description. Please try describing what you're looking for in terms of historical sites, beaches, desert experiences, or cultural attractions.\")\n                    return {\"city_description\": None}\n            else:\n                dispatcher.utter_message(\"Sorry, I couldn't process your city description. Please try again with a different description.\")\n                return {\"city_description\": None}\n        except Exception as e:\n            dispatcher.utter_message(\n                f\"Something went wrong while processing your city description. Please try again. Error: {str(e)}\")\n            return {\"city_description\": None}\n\n    def validate_selected_city(self,\n                       slot_value: Any,\n                       dispatcher: CollectingDispatcher,\n                       tracker: Tracker,\n                       domain: Dict[Text, Any]) -> Dict[Text, Any]:\n        \n        # Get the city from either the slot value or the latest message\n        city = slot_value or tracker.latest_message.get('text', '').strip()\n        \n        # Get suggested cities\n        suggested_cities = tracker.get_slot(\"suggested_cities\") or []\n        \n        # Check if the user's input matches any of the suggested cities\n        for suggested_city in suggested_cities:\n            if city.lower() == suggested_city.lower():\n                user_messages = tracker.get_slot(\"user_message\") or {}\n                user_messages[\"state\"] = tracker.latest_message.get('text', '')\n                return {\n                    \"selected_city\": suggested_city,  # Use the exact city name from suggestions\n                    \"state\": suggested_city,  # Also set the state slot\n                    \"user_message\": user_messages,\n                    \"awaiting_city_selection\": False,\n                    \"requested_slot\": \"budget\"\n                }\n        \n        # If no match found, ask the user to choose from the suggested cities\n        dispatcher.utter_message(\"Please choose one of the suggested cities.\")\n        return {\"selected_city\": None}\n\n    def validate_state(self,\n                       slot_value: Any,\n                       dispatcher: CollectingDispatcher,\n                       tracker: Tracker,\n                       domain: Dict[Text, Any]) -> Dict[Text, Any]:\n        # Get the city from either the slot value or the latest message\n        city = slot_value or tracker.latest_message.get('text', '').strip()\n        \n        # Check if we're awaiting city selection\n        if tracker.get_slot(\"awaiting_city_selection\"):\n            suggested_cities = tracker.get_slot(\"suggested_cities\") or []\n            \n            # Check if the user's input matches any of the suggested cities\n            for suggested_city in suggested_cities:\n                if city.lower() == suggested_city.lower():\n                    user_messages = tracker.get_slot(\"user_message\") or {}\n                    user_messages[\"state\"] = tracker.latest_message.get('text', '')\n                    return {\n                        \"state\": suggested_city,  # Use the exact city name from suggestions\n                        \"user_message\": user_messages,\n                        \"awaiting_city_selection\": False,\n                        \"requested_slot\": \"budget\"\n                    }\n            \n            # If no match found, ask the user to choose from the suggested cities\n            dispatcher.utter_message(\"Please choose one of the suggested cities.\")\n            return {\"state\": None}\n        \n        # If not awaiting selection, check if the city is in our list of valid cities\n        if city.lower() in [city.lower() for city in CITIES_NAMES]:\n            user_messages = tracker.get_slot(\"user_message\") or {}\n            user_messages[\"state\"] = tracker.latest_message.get('text', '')\n            return {\n                \"state\": city,\n                \"user_message\": user_messages,\n                \"requested_slot\": \"budget\"\n            }\n        else:\n            dispatcher.utter_message(\"Sorry, we don't have Trips in this city. Can you choose another destination?\")\n            return {\"state\": None}\n\n    def validate_budget(self, slot_value: Any, dispatcher: CollectingDispatcher, tracker: Tracker,\n                        domain: Dict[Text, Any]) -> Dict[Text, Any]:\n        print(\"=== validate_budget called ===\")\n        print(f\"Slot value: {slot_value}\")\n        try:\n            # Convert slot_value to string if it's not already\n            if not isinstance(slot_value, str):\n                slot_value = str(slot_value)\n\n            match = re.match(r'(\\$?\\d+|[\\w\\s-]+\\$?)\\s*(dollar|dollars|usd)?', slot_value, re.IGNORECASE)\n            if not match:\n                dispatcher.utter_message(\"Please enter a valid budget (e.g., '500 dollars', 'one hundred USD').\")\n                return {\"budget\": None}\n\n            number_part, currency = match.groups()\n\n            if number_part.startswith('$'):\n                number_part = number_part[1:]\n            elif number_part.endswith('$'):\n                number_part = number_part[:-1]\n\n            try:\n                # First try to convert directly to int\n                budget = int(number_part)\n            except ValueError:\n                try:\n                    # If direct conversion fails, try word to number conversion\n                    budget = w2n.word_to_num(number_part)\n                except ValueError:\n                    dispatcher.utter_message(\"Please enter a valid number for the budget.\")\n                    return {\"budget\": None}\n\n            if budget <= 0:\n                dispatcher.utter_message(\"Please enter a valid positive budget.\")\n                return {\"budget\": None}\n\n            # Add reasonable budget limits\n            if budget > 1000000:  # Example upper limit\n                dispatcher.utter_message(\"Please enter a more reasonable budget amount.\")\n                return {\"budget\": None}\n\n            if not self.is_trip_available_within_budget(budget):\n                dispatcher.utter_message(\n                    \"Sorry, we don't have any trips available within your budget. Please try a higher budget.\")\n                return {\"budget\": None}\n\n            # Store the user message\n            user_message = tracker.get_slot(\"user_message\") or {}\n            user_message[\"budget\"] = tracker.latest_message.get('text', '')\n            return {\"budget\": budget, \"user_message\": user_message}\n\n        except Exception as e:\n            logger.error(f\"Error validating budget: {str(e)}\")\n            dispatcher.utter_message(\"Something went wrong while processing your budget. Please try again.\")\n            return {\"budget\": None}\n\n    def is_trip_available_within_budget(self, budget: float) -> bool:\n\n        # Replace this with actual logic to check if there are trips within the budget\n\n        return budget >= 100\n\n    def validate_duration(self, slot_value: Any, dispatcher: CollectingDispatcher, tracker: Tracker,\n                          domain: Dict[Text, Any]) -> Dict[Text, Any]:\n        try:\n            # Convert slot_value to string if it's not already\n            if not isinstance(slot_value, str):\n                slot_value = str(slot_value)\n\n            # More flexible regex pattern that handles various formats\n            match = re.match(r'(\\d+|[\\w\\s-]+)\\s*(day|week|month|days|weeks|months)?', slot_value.lower())\n            if not match:\n                dispatcher.utter_message(\"Please enter a valid duration (e.g., '7 days', 'two weeks', '1 month', '3').\")\n                return {\"duration\": None}\n\n            number_part, unit = match.groups()\n            number_part = number_part.strip()\n\n            # Try to convert the number part\n            try:\n                # First try direct integer conversion\n                number = int(number_part)\n            except ValueError:\n                try:\n                    # If that fails, try word to number conversion\n                    number = w2n.word_to_num(number_part)\n                except ValueError:\n                    dispatcher.utter_message(\"Please enter a valid number for the duration.\")\n                    return {\"duration\": None}\n\n            # If no unit is specified, assume days\n            if not unit:\n                unit = \"days\"\n            else:\n                unit = unit.lower()\n\n            # Convert to days based on unit\n            if unit in [\"day\", \"days\"]:\n                duration_days = number\n            elif unit in [\"week\", \"weeks\"]:\n                duration_days = number * 7\n            elif unit in [\"month\", \"months\"]:\n                duration_days = number * 30\n            else:\n                dispatcher.utter_message(\"Please specify a valid unit (days, weeks, or months).\")\n                return {\"duration\": None}\n\n            # Validate the duration\n            if duration_days <= 0:\n                dispatcher.utter_message(\"Please enter a valid duration greater than zero.\")\n                return {\"duration\": None}\n            \n            if duration_days > 365:  # Add a reasonable upper limit\n                dispatcher.utter_message(\"Please enter a duration of one year or less.\")\n                return {\"duration\": None}\n\n            # Store the user message\n            user_message = tracker.get_slot(\"user_message\") or {}\n            user_message[\"duration\"] = tracker.latest_message.get('text', '')\n            \n            return {\n                \"duration\": duration_days,\n                \"user_message\": user_message\n            }\n\n        except Exception as e:\n            logger.error(f\"Error validating duration: {str(e)}\")\n            dispatcher.utter_message(\"Something went wrong while processing the duration. Please try again.\")\n            return {\"duration\": None}\n\n    # Validate the arrival date\n    def validate_arrival_date(self, slot_value: Any, dispatcher: CollectingDispatcher, tracker: Tracker,\n                              domain: Dict[Text, Any]) -> Dict[Text, Any]:\n\n        try:\n            date_or_range = self.parse_flexible_date(slot_value)\n\n            if not date_or_range:\n                dispatcher.utter_message(\n                    \"Please enter a valid date or time frame (e.g., 'next week', '15th October', 'summer').\")\n                return {\"arrival_date\": None}\n\n            if isinstance(date_or_range, datetime):\n                if date_or_range < datetime.now():\n                    dispatcher.utter_message(\n                        \"The arrival date cannot be in the past. Please enter a future date or time frame.\")\n                    return {\"arrival_date\": None}\n                unified_date = date_or_range.strftime(\"%Y-%m-%d\")\n            else:\n                start_date, end_date = date_or_range\n                if start_date < datetime.now():\n                    dispatcher.utter_message(\n                        \"The arrival date cannot be in the past. Please enter a future date or time frame.\")\n                    return {\"arrival_date\": None}\n                unified_date = [start_date.strftime('%Y-%m-%d'), end_date.strftime('%Y-%m-%d')]\n\n            # Store the user message in the slot\n            user_messages = tracker.get_slot(\"user_message\") or {}\n            user_messages[\"arrival_date\"] = tracker.latest_message.get('text', '')\n            return {\"arrival_date\": unified_date, \"user_message\": user_messages}\n\n        except Exception as e:\n\n            dispatcher.utter_message(\"Something went wrong while processing the date. Please try again.\")\n            return {\"arrival_date\": None}\n\n    def parse_flexible_date(self, date_input: str) -> Optional[Union[datetime, Tuple[datetime, datetime]]]:\n        \"\"\"\n        Parses flexible date inputs like \"next week\", \"15th October\", \"summer\", etc.\n        Returns a datetime object (for absolute dates) or a tuple of datetime objects (for date ranges).\n        \"\"\"\n        date_input = date_input.lower()\n        today = datetime.now()\n        # Handle relative dates\n        if \"next week\" in date_input:\n            start_date = today + timedelta(weeks=1)\n            end_date = start_date + timedelta(days=6)\n            return (start_date, end_date)\n        elif \"next month\" in date_input:\n            start_date = today + relativedelta(months=1, day=1)\n            end_date = start_date + relativedelta(day=31)\n            return (start_date, end_date)\n        elif \"next year\" in date_input:\n            start_date = today + relativedelta(years=1, month=1, day=1)\n            end_date = start_date + relativedelta(month=12, day=31)\n            return (start_date, end_date)\n        elif \"next season\" in date_input:\n            return self.get_next_season_range(today)\n        elif \"next quarter\" in date_input:\n            return self.get_next_quarter_range(today)\n\n        # Handle seasons\n        if \"summer\" in date_input:\n            return self.get_season_range(today.year, \"summer\")\n        elif \"autumn\" in date_input or \"fall\" in date_input:\n            return self.get_season_range(today.year, \"autumn\")\n        elif \"winter\" in date_input:\n            return self.get_season_range(today.year, \"winter\")\n        elif \"spring\" in date_input:\n            return self.get_season_range(today.year, \"spring\")\n\n        # Handle absolute dates\n        absolute_date = self.parse_absolute_date(date_input)\n        if absolute_date:\n            return absolute_date\n\n        # Handle months\n        month_range = self.parse_month_range(date_input)\n        if month_range:\n            return month_range\n\n        return None\n\n    def parse_absolute_date(self, date_input: str) -> Optional[datetime]:\n        \"\"\"\n        Parses absolute dates like \"15th October\", \"1st January\", etc.\n        Returns a datetime object or None if parsing fails.\n        \"\"\"\n        try:\n            date_input = re.sub(r'(\\d+)(st|nd|rd|th)', r'\\1', date_input)\n\n            # Try parsing with common date formats\n            date_formats = [\n                \"%d %B %Y\",  # 15 October 2023\n                \"%d %b %Y\",  # 15 Oct 2023\n                \"%d %B\",  # 15 October (assumes current year)\n                \"%d %b\",  # 15 Oct (assumes current year)\n            ]\n\n            for fmt in date_formats:\n                try:\n                    return datetime.strptime(date_input, fmt)\n                except ValueError:\n                    continue\n            return None\n        except Exception:\n            return None\n\n    def parse_month_range(self, date_input: str) -> Optional[Tuple[datetime, datetime]]:\n        \"\"\"\n        Parse month names like \"March\", \"June\", etc.\n        Returns a tuple of datetime objects representing the start and end of the month.\n        \"\"\"\n        try:\n            month_names = {\n                \"january\": 1, \"february\": 2, \"march\": 3, \"april\": 4,\n                \"may\": 5, \"june\": 6, \"july\": 7, \"august\": 8,\n                \"september\": 9, \"october\": 10, \"november\": 11, \"december\": 12,\n            }\n\n            for month_name, month_num in month_names.items():\n                if month_name in date_input:\n                    year = datetime.now().year\n                    start_date = datetime(year, month_num, 1)\n                    end_date = start_date + relativedelta(day=31)\n                    return (start_date, end_date)\n            return None\n        except Exception:\n            return None\n\n    def get_season_range(self, year: int, season: str) -> Tuple[datetime, datetime]:\n        \"\"\"\n        Returns the start and end dates of a season for a given year.\n        \"\"\"\n        if season == \"spring\":\n            return (datetime(year, 3, 1), datetime(year, 5, 31))\n        elif season == \"summer\":\n            return (datetime(year, 6, 1), datetime(year, 8, 31))\n        elif season == \"autumn\":\n            return (datetime(year, 9, 1), datetime(year, 11, 30))\n        elif season == \"winter\":\n            return (datetime(year, 12, 1), datetime(year + 1, 2, 28))\n        else:\n            # Default to spring if season is invalid\n            return (datetime(year, 3, 1), datetime(year, 5, 31))\n\n    def get_next_season_range(self, today: datetime) -> Tuple[datetime, datetime]:\n        \"\"\"\n        Returns the start and end dates of the next season.\n        \"\"\"\n        current_month = today.month\n        if current_month < 3:\n            return (datetime(today.year, 3, 1), datetime(today.year, 5, 31))  # Spring\n        elif current_month < 6:\n            return (datetime(today.year, 6, 1), datetime(today.year, 8, 31))  # Summer\n        elif current_month < 9:\n            return (datetime(today.year, 9, 1), datetime(today.year, 11, 30))  # Autumn\n        elif current_month < 12:\n            return (datetime(today.year, 12, 1), datetime(today.year + 1, 2, 28))  # Winter\n        else:\n            return (datetime(today.year + 1, 3, 1), datetime(today.year + 1, 5, 31))  # Next spring\n\n    def get_next_quarter_range(self, today: datetime) -> Tuple[datetime, datetime]:\n        \"\"\"\n        Returns the start and end dates of the next quarter.\n        \"\"\"\n        current_month = today.month\n        if current_month < 4:\n            return (datetime(today.year, 4, 1), datetime(today.year, 6, 30))\n        elif current_month < 7:\n            return (datetime(today.year, 7, 1), datetime(today.year, 9, 30))\n        elif current_month < 10:\n            return (datetime(today.year, 10, 1), datetime(today.year, 12, 31))\n        else:\n            return (datetime(today.year + 1, 1, 1), datetime(today.year + 1, 3, 31))\n\n    def validate_hotel_features(self, slot_value: Any, dispatcher: CollectingDispatcher, tracker: Tracker,\n                                domain: Dict[Text, Any]) -> Dict[Text, Any]:\n        user_message = tracker.get_slot(\"user_message\") or {}\n        user_message[\"hotel_features\"] = tracker.latest_message.get('text', '')\n        return {\"hotel_features\": slot_value, \"user_message\": user_message}\n\n    def validate_landmarks_activities(self, slot_value: Any, dispatcher: CollectingDispatcher, tracker: Tracker,\n                                      domain: Dict[Text, Any]) -> Dict[Text, Any]:\n        user_message = tracker.get_slot(\"user_message\") or {}\n        user_message[\"landmarks_activities\"] = tracker.latest_message.get('text', '')\n        return {\"landmarks_activities\": slot_value, \"user_message\": user_message}\n\n\n\n\n\n\n\n
===================================================================
diff --git a/actions/validation_action.py b/actions/validation_action.py
--- a/actions/validation_action.py	(revision 65afd03d54365f9bd4047233bede59f479d268df)
+++ b/actions/validation_action.py	(date 1749796266554)
@@ -154,19 +154,25 @@
 
         return {"specify_place": None}
 
-    @staticmethod
-    def validate_city_description(self, slot_value: Any, dispatcher: CollectingDispatcher, tracker: Tracker,
-                                  domain: Dict[Text, Any]) -> Dict[Text, Any]:
+    def validate_city_description(
+            self,
+            slot_value: Any,
+            dispatcher: CollectingDispatcher,
+            tracker: Tracker,
+            domain: Dict[Text, Any]
+    ) -> Dict[Text, Any]:
         try:
             api_url = get_api_urls()
             if not api_url:
                 raise KeyError("'suggest_cities' key not found in API URLs configuration")
 
-            # Extract city features from the description
-            city_features = []
             if isinstance(slot_value, str):
                 # Common non-Egyptian features to check for
                 non_egyptian_features = {
+                    'eiffel tower': 'Egypt doesn\'t have the Eiffel Tower, but we have the Great Pyramid of Giza',
+                    'great wall': 'Egypt doesn\'t have the Great Wall, but we have the Sphinx and Pyramids',
+                    'niagara falls': 'Egypt doesn\'t have Niagara Falls, but we have the Nile River',
+                    'grand canyon': 'Egypt doesn\'t have the Grand Canyon, but we have the White Desert',
                     'ski slopes': 'Egypt doesn\'t have ski slopes, but we have beautiful desert landscapes',
                     'volcanoes': 'Egypt doesn\'t have volcanoes, but we have ancient pyramids and temples',
                     'rainforests': 'Egypt doesn\'t have rainforests, but we have the Nile Valley and oases',
@@ -196,24 +202,28 @@
                 for feature, alternative in non_egyptian_features.items():
                     if feature.lower() in slot_value.lower():
                         dispatcher.utter_message(f"Note: {alternative}")
-            cities_url=f"{api_url['base_url']}/cities/search"
+            
+            cities_url = f"{api_url['base_url']}/cities/recommend"
             response = requests.post(
                 cities_url,
-                json={
-                    "city_description": slot_value,
-                    "city_features": city_features
-                }
+                json={"city_description": slot_value}
             )
+            
             if response.status_code == 200:
-                suggested_cities = response.json().get("top_cities", [])
+                data = response.json()
+                suggested_cities = data.get("top_cities", [])
                 
                 if suggested_cities:
-                    # Format the cities for display
-                    suggested_cities_msg = "\n".join(
-                        [f"{i+1}. {city['name']} - {city['description']}" for i, city in enumerate(suggested_cities)]
-                    )
+                    # Format the cities for display with their matched features
+                    suggested_cities_msg = []
+                    for i, city in enumerate(suggested_cities):
+                        features_msg = ", ".join([f"{f['name']}" for f in city.get('matched_features', [])])
+                        city_msg = f"{i+1}. {city['name']} - {city['description']}"
+                        if features_msg:
+                            city_msg += f"\n   Matches your interests in: {features_msg}"
+                        suggested_cities_msg.append(city_msg)
                     
-                    dispatcher.utter_message(text=f"Here are some suggested cities that may suit you:\n{suggested_cities_msg}")
+                    dispatcher.utter_message(text=f"Here are some suggested cities that may suit you:\n" + "\n\n".join(suggested_cities_msg))
                     dispatcher.utter_message(text="Please choose one of these cities for your trip.")
                     
                     # Store just the city names in the suggested_cities slot
@@ -222,7 +232,6 @@
                     # Store the city description and set awaiting_city_selection to true
                     return {
                         "city_description": slot_value,
-                        "city_features": city_features,
                         "suggested_cities": city_names,
                         "awaiting_city_selection": True,
                         "requested_slot": "selected_city"
@@ -233,9 +242,10 @@
             else:
                 dispatcher.utter_message("Sorry, I couldn't process your city description. Please try again with a different description.")
                 return {"city_description": None}
+            
         except Exception as e:
-            dispatcher.utter_message(
-                f"Something went wrong while processing your city description. Please try again. Error: {str(e)}")
+            logger.error(f"Error in validate_city_description: {str(e)}")
+            dispatcher.utter_message("I'm having trouble processing your city description. Could you please try again?")
             return {"city_description": None}
 
     def validate_selected_city(self,
