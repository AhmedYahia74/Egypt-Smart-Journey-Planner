Index: actions/actions.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import requests\nfrom rasa_sdk import Tracker, FormValidationAction, Action\nfrom rasa_sdk.executor import CollectingDispatcher\nfrom rasa_sdk.events import SlotSet, Restarted\nfrom typing import Any, Text, Dict, List, Tuple, Optional, Union\nfrom datetime import datetime, timedelta\nfrom dateutil.relativedelta import relativedelta\nfrom Store_User_Messages import Store_User_Messages\nfrom word2number import w2n\nfrom config_helper import get_db_params, get_api_urls\nimport psycopg2\nimport re\nimport logging\n\nlogging.basicConfig(level=logging.DEBUG)\nprint(\"âœ… Custom Action Server is running...\")  # Debugging message\n\nDB_Prams=get_db_params()\nstore_msgs=Store_User_Messages()\n\ndef fetch_cities_from_database():\n    conn=None\n    cur=None\n    cities_names = []\n    try:\n        conn=psycopg2.connect(**DB_Prams)\n        cur=conn.cursor()\n        cur.execute(\"SELECT * FROM states\")\n        for row in cur:\n            cities_names.append(row[1])\n        return cities_names\n    except Exception as e:\n        print(f\"Error: {e}\")\n    finally:\n        if cur:\n            cur.close()\n        if conn:\n            conn.close()\n    return cities_names\n\n\nCITIES_NAMES = fetch_cities_from_database()\n\n\nclass ValidateTripForm(FormValidationAction):\n\n    def name(self) -> Text:\n        return \"validate_trip_form\"\n\n    async def required_slots(\n        self,\n        domain_slots: List[Text],\n        dispatcher: \"CollectingDispatcher\",\n        tracker: \"Tracker\",\n        domain: Dict[Text, Any],\n    ) -> List[Text]:\n        required_slots=[]\n\n\n        if tracker.get_slot(\"state\") is None and tracker.get_slot(\"specify_place\") is None:\n            required_slots.append(\"specify_place\")\n        if tracker.get_slot(\"specify_place\") is True:\n            required_slots.append(\"state\")\n        elif tracker.get_slot(\"specify_place\") is False :\n            required_slots.append( \"city_description\")\n\n        required_slots.extend([ \"budget\", \"duration\", \"arrival_date\", \"hotel_features\", \"landmarks_activities\"])\n\n        return required_slots\n\n\n\n    def validate_specify_place(self,\n                            slot_value: Any,\n                            dispatcher: CollectingDispatcher,\n                            tracker: Tracker,\n                            domain: Dict[Text, Any]) -> Dict[Text, Any]:\n\n        intent=tracker.latest_message['intent'].get('name')\n        if intent == \"deny\":\n            return {\"specify_place\": False}\n        elif intent == \"affirm\":\n            return {\"specify_place\": True}\n        return {\"specify_place\": None}\n\n    def validate_state(self,\n                       slot_value: Any,\n                       dispatcher: CollectingDispatcher,\n                       tracker: Tracker,\n                       domain: Dict[Text, Any]) -> Dict[Text, Any]:\n        country = tracker.get_slot(\"state\")\n        if country.lower() in [city.lower() for city in CITIES_NAMES]:\n            return {\"state\": country}\n        else:\n            dispatcher.utter_message(\"Sorry, we don't have Trips in this city, Can you choose another destination?\")\n            return {\"state\": None}\n\n    def validate_weather_preference(self, slot_value: Any, dispatcher: CollectingDispatcher, tracker: Tracker,\n                                    domain: Dict[Text, Any]) -> Dict[Text, Any]:\n        store_msgs.store_user_message(\"weather_preference\", slot_value, tracker.latest_message.get('text', ''),\n                                      tracker.sender_id)\n        return {\"weather_preference\": slot_value}\n\n    def validate_city_description(self, slot_value: Any, dispatcher: CollectingDispatcher, tracker: Tracker,\n                                      domain: Dict[Text, Any]) -> Dict[Text, Any]:\n        try:\n            response = requests.get(get_api_urls()[\"suggest_city\"], params={\"user_msgs\": slot_value})\n            if response.status_code == 200:\n                buttons = [{\"title\": city['name'], \"payload\": f\"/inform{{\\\"state\\\": \\\"{city['name']}\\\"}}\"} for city in\n                           response.json()[\"top_cities\"]]\n                dispatcher.utter_message(text=\"Here are some suggested cities that may suit you\", buttons=buttons)\n                store_msgs.store_user_message(\"city_description\", slot_value, tracker.latest_message.get('text', ''),\n                                              tracker.sender_id)\n                return {\"city_description\": slot_value}\n            else:\n                dispatcher.utter_message(\"Sorry, I couldn't process your city description. Please try again.\")\n                return {\"city_description\": None}\n        except Exception as e:\n            dispatcher.utter_message(\n                f\"Something went wrong while processing your city description. Please try again. Error: {str(e)}\")\n            return {\"city_description\": None}\n\n    def validate_budget(self, slot_value: Any, dispatcher: CollectingDispatcher, tracker: Tracker, domain: Dict[Text, Any]) -> Dict[Text, Any]:\n        try:\n            match = re.match(r'(\\$?\\d+|[\\w\\s-]+)\\s*(dollar|dollars|usd)?', slot_value, re.IGNORECASE)\n            if not match:\n                dispatcher.utter_message(\"Please enter a valid budget (e.g., '500 dollars', 'one hundred USD').\")\n                return {\"budget\": None}\n\n            number_part, currency = match.groups()\n\n            if number_part.startswith('$'):\n                number_part = number_part[1:]\n\n            try:\n                budget = int(number_part)\n            except ValueError:\n                try:\n                    budget = w2n.word_to_num(number_part)\n                except ValueError:\n                    dispatcher.utter_message(\"Please enter a valid number for the budget.\")\n                    return {\"budget\": None}\n\n            if budget <= 0:\n                dispatcher.utter_message(\"Please enter a valid positive budget.\")\n                return {\"budget\": None}\n\n            if not self.is_trip_available_within_budget(budget):\n                dispatcher.utter_message(\"Sorry, we don't have any trips available within your budget. Please try a higher budget.\")\n                return {\"budget\": None}\n            store_msgs.store_user_message(\"budget\", budget, tracker.latest_message.get('text', ''), tracker.sender_id)\n\n            return {\"budget\": budget}\n\n        except Exception as e:\n            dispatcher.utter_message(\"Something went wrong while processing the budget. Please try again.\")\n            return {\"budget\": None}\n\n    def is_trip_available_within_budget(self, budget: float) -> bool:\n\n        # Replace this with actual logic to check if there are trips within the budget\n\n        return budget >= 100\n\n    def validate_duration(self, slot_value: Any, dispatcher: CollectingDispatcher, tracker: Tracker, domain: Dict[Text, Any]) -> Dict[Text, Any]:\n        try:\n            match = re.match(r'(\\d+|[\\w\\s-]+)\\s*(day|week|month|days|weeks|months)', slot_value, re.IGNORECASE)\n            if not match:\n                dispatcher.utter_message(\"Please enter a valid duration (e.g., '7 days', 'two weeks', '1 month').\")\n                return {\"duration\": None}\n\n            number_part, unit = match.groups()\n\n            try:\n                number = int(number_part)\n            except ValueError:\n                try:\n                    number = w2n.word_to_num(number_part)\n                except ValueError:\n                    dispatcher.utter_message(\"Please enter a valid number for the duration.\")\n                    return {\"duration\": None}\n\n            if unit.lower() in [\"day\", \"days\"]:\n                duration_days = number\n            elif unit.lower() in [\"week\", \"weeks\"]:\n                duration_days = number * 7\n            elif unit.lower() in [\"month\", \"months\"]:\n                duration_days = number * 30\n            else:\n                dispatcher.utter_message(\"Please specify a valid unit (e.g., days, weeks, months).\")\n                return {\"duration\": None}\n\n            if duration_days <= 0:\n                dispatcher.utter_message(\"Please enter a valid duration,the duration should be greater than zero.\")\n                return {\"duration\": None}\n            store_msgs.store_user_message(\"duration\", duration_days, tracker.latest_message.get('text', ''), tracker.sender_id)\n\n            return {\"duration\": duration_days}\n\n        except Exception as e:\n            dispatcher.utter_message(\"Something went wrong while processing the duration. Please try again.\")\n            return {\"duration\": None}\n\n    # Validate the arrival date\n    def validate_arrival_date(self, slot_value: Any, dispatcher: CollectingDispatcher, tracker: Tracker, domain: Dict[Text, Any]) -> Dict[Text, Any]:\n\n        try:\n            date_or_range = self.parse_flexible_date(slot_value)\n\n            if not date_or_range:\n                dispatcher.utter_message(\"Please enter a valid date or time frame (e.g., 'next week', '15th October', 'summer').\")\n                return {\"arrival_date\": None}\n\n            if isinstance(date_or_range, datetime):\n                if date_or_range < datetime.now():\n                    dispatcher.utter_message(\"The arrival date cannot be in the past. Please enter a future date or time frame.\")\n                    return {\"arrival_date\": None}\n                unified_date = date_or_range.strftime(\"%Y-%m-%d\")\n            else:\n                start_date, end_date = date_or_range\n                if start_date < datetime.now():\n                    dispatcher.utter_message(\"The arrival date cannot be in the past. Please enter a future date or time frame.\")\n                    return {\"arrival_date\": None}\n                unified_date = [start_date.strftime('%Y-%m-%d'), end_date.strftime('%Y-%m-%d')]\n\n            if not self.is_trip_available_on_date(unified_date):\n\n                dispatcher.utter_message(\"Sorry, there are no trips available for this date or time frame. Please choose another.\")\n                return {\"arrival_date\": None}\n\n            store_msgs.store_user_message(\"arrival_date\", unified_date, tracker.latest_message.get('text', ''), tracker.sender_id)\n\n            return {\"arrival_date\": unified_date}\n\n        except Exception as e:\n\n            dispatcher.utter_message(\"Something went wrong while processing the date. Please try again.\")\n            return {\"arrival_date\": None}\n\n    def parse_flexible_date(self, date_input: str) -> Optional[Union[datetime, Tuple[datetime, datetime]]]:\n        \"\"\"\n        Parses flexible date inputs like \"next week\", \"15th October\", \"summer\", etc.\n        Returns a datetime object (for absolute dates) or a tuple of datetime objects (for date ranges).\n        \"\"\"\n        date_input = date_input.lower()\n        today = datetime.now()\n        # Handle relative dates\n        if \"next week\" in date_input:\n            start_date = today + timedelta(weeks=1)\n            end_date = start_date + timedelta(days=6)\n            return (start_date, end_date)\n        elif \"next month\" in date_input:\n            start_date = today + relativedelta(months=1, day=1)\n            end_date = start_date + relativedelta(day=31)\n            return (start_date, end_date)\n        elif \"next year\" in date_input:\n            start_date = today + relativedelta(years=1, month=1, day=1)\n            end_date = start_date + relativedelta(month=12, day=31)\n            return (start_date, end_date)\n        elif \"next season\" in date_input:\n            return self.get_next_season_range(today)\n        elif \"next quarter\" in date_input:\n            return self.get_next_quarter_range(today)\n\n        # Handle seasons\n        if \"summer\" in date_input:\n            return self.get_season_range(today.year, \"summer\")\n        elif \"autumn\" in date_input or \"fall\" in date_input:\n            return self.get_season_range(today.year, \"autumn\")\n        elif \"winter\" in date_input:\n            return self.get_season_range(today.year, \"winter\")\n        elif \"spring\" in date_input:\n            return self.get_season_range(today.year, \"spring\")\n\n        # Handle absolute dates\n        absolute_date = self.parse_absolute_date(date_input)\n        if absolute_date:\n            return absolute_date\n\n        # Handle months\n        month_range = self.parse_month_range(date_input)\n        if month_range:\n            return month_range\n\n        return None\n\n    def parse_absolute_date(self, date_input: str) -> Optional[datetime]:\n        \"\"\"\n        Parses absolute dates like \"15th October\", \"1st January\", etc.\n        Returns a datetime object or None if parsing fails.\n        \"\"\"\n        try:\n            date_input = re.sub(r'(\\d+)(st|nd|rd|th)', r'\\1', date_input)\n            \n            # Try parsing with common date formats\n            date_formats = [\n                \"%d %B %Y\",  # 15 October 2023\n                \"%d %b %Y\",  # 15 Oct 2023\n                \"%d %B\",     # 15 October (assumes current year)\n                \"%d %b\",     # 15 Oct (assumes current year)\n            ]\n            \n            for fmt in date_formats:\n                try:\n                    return datetime.strptime(date_input, fmt)\n                except ValueError:\n                    continue\n            return None\n        except Exception:\n            return None\n\n    def parse_month_range(self, date_input: str) -> Optional[Tuple[datetime, datetime]]:\n        \"\"\"\n        Parses month names like \"March\", \"June\", etc.\n        Returns a tuple of datetime objects representing the start and end of the month.\n        \"\"\"\n        try:\n            month_names = {\n                \"january\": 1, \"february\": 2, \"march\": 3, \"april\": 4,\n                \"may\": 5, \"june\": 6, \"july\": 7, \"august\": 8,\n                \"september\": 9, \"october\": 10, \"november\": 11, \"december\": 12,\n            }\n            \n            for month_name, month_num in month_names.items():\n                if month_name in date_input:\n                    year = datetime.now().year\n                    start_date = datetime(year, month_num, 1)\n                    end_date = start_date + relativedelta(day=31)\n                    return (start_date, end_date)\n            return None\n        except Exception:\n            return None\n\n    def get_season_range(self, year: int, season: str) -> Tuple[datetime, datetime]:\n        \"\"\"\n        Returns the start and end dates of a season for a given year.\n        \"\"\"\n        if season == \"spring\":\n            return (datetime(year, 3, 1), datetime(year, 5, 31))\n        elif season == \"summer\":\n            return (datetime(year, 6, 1), datetime(year, 8, 31))\n        elif season == \"autumn\":\n            return (datetime(year, 9, 1), datetime(year, 11, 30))\n        elif season == \"winter\":\n            return (datetime(year, 12, 1), datetime(year + 1, 2, 28))\n        return None\n\n    def get_next_season_range(self, today: datetime) -> Tuple[datetime, datetime]:\n        \"\"\"\n        Returns the start and end dates of the next season.\n        \"\"\"\n        current_month = today.month\n        if current_month < 3:\n            return (datetime(today.year, 3, 1), datetime(today.year, 5, 31))  # Spring\n        elif current_month < 6:\n            return (datetime(today.year, 6, 1), datetime(today.year, 8, 31))  # Summer\n        elif current_month < 9:\n            return (datetime(today.year, 9, 1), datetime(today.year, 11, 30))  # Autumn\n        elif current_month < 12:\n            return (datetime(today.year, 12, 1), datetime(today.year + 1, 2, 28))  # Winter\n        else:\n            return (datetime(today.year + 1, 3, 1), datetime(today.year + 1, 5, 31))  # Next spring\n\n    def get_next_quarter_range(self, today: datetime) -> Tuple[datetime, datetime]:\n        \"\"\"\n        Returns the start and end dates of the next quarter.\n        \"\"\"\n        current_month = today.month\n        if current_month < 4:\n            return (datetime(today.year, 4, 1), datetime(today.year, 6, 30))\n        elif current_month < 7:\n            return (datetime(today.year, 7, 1), datetime(today.year, 9, 30))\n        elif current_month < 10:\n            return (datetime(today.year, 10, 1), datetime(today.year, 12, 31))\n        else:\n            return (datetime(today.year + 1, 1, 1), datetime(today.year + 1, 3, 31))\n\n    def is_trip_available_on_date(self, date_or_range: Union[str, Tuple[datetime, datetime]]) -> bool:\n        \"\"\"\n        Checks if a trip is available on the given date or within the date range.\n        Replace this with actual logic to check trip availability.\n        \"\"\"\n        return True\n\n    def validate_hotel_features(self, slot_value: Any, dispatcher: CollectingDispatcher, tracker: Tracker, domain: Dict[Text, Any]) -> Dict[Text, Any]:\n        store_msgs.store_user_message(\"hotel_features\", slot_value, tracker.latest_message.get('text', ''), tracker.sender_id)\n\n        return {\"hotel_features\": slot_value}\n    def validate_landmarks_activities(self, slot_value: Any, dispatcher: CollectingDispatcher, tracker: Tracker, domain: Dict[Text, Any]) -> Dict[Text, Any]:\n        store_msgs.store_user_message(\"landmarks_activities\", slot_value, tracker.latest_message.get('text', ''), tracker.sender_id)\n\n        return {\"landmarks_activities\": slot_value}\n\n\n\n\n\nclass ActionClearChat(Action):\n    def name(self) -> Text:\n        return \"action_clear_chat\"\n\n    async def run(self, dispatcher, tracker: Tracker, domain):\n        conn=None\n        cur=None\n        try:\n            conn=psycopg2.connect(**DB_Prams)\n            cur=conn.cursor()\n            cur.execute(\"UPDATE conversation_data SET user_msgs= %s, slot_values= %s  WHERE conversation_id=%s\",(None,None,tracker.sender_id,))\n            conn.commit()\n        except Exception as e:\n            print(f\"Error: {e}\")\n        finally:\n            if cur:\n                cur.close()\n            if conn:\n                conn.close()\n        return [SlotSet(slot, None) for slot in tracker.slots.keys()] + [Restarted()]\n\n\nclass StoreUserMessages(Action):\n    def name(self) -> Text:\n        return \"action_store_user_messages\"\n\n    def run(self, dispatcher: CollectingDispatcher, tracker: Tracker, domain: Dict[Text, Any]) -> List[Dict[Text, Any]]:\n        for key in tracker.slots.keys():\n            if tracker.slots[key]:\n                store_msgs.store_user_message(key, tracker.get_slot(key), tracker.latest_message.get('text', ''), tracker.sender_id)
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/actions/actions.py b/actions/actions.py
--- a/actions/actions.py	(revision 123933349ceb9f49cc43d94a2543fee055ca2e40)
+++ b/actions/actions.py	(date 1745072903669)
@@ -109,8 +109,7 @@
                 buttons = [{"title": city['name'], "payload": f"/inform{{\"state\": \"{city['name']}\"}}"} for city in
                            response.json()["top_cities"]]
                 dispatcher.utter_message(text="Here are some suggested cities that may suit you", buttons=buttons)
-                store_msgs.store_user_message("city_description", slot_value, tracker.latest_message.get('text', ''),
-                                              tracker.sender_id)
+
                 return {"city_description": slot_value}
             else:
                 dispatcher.utter_message("Sorry, I couldn't process your city description. Please try again.")
